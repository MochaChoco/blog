---
title: "네이버 댓글 종료 대응, Vanilla JS 댓글 모듈 자체 개발기"
description: "네이버 공통 댓글 모듈 종료에 대응하여, 프레임워크 독립적인 Vanilla JS 댓글 모듈을 설계·개발하고 Nuxt 3 프로젝트에 통합한 과정을 공유합니다."
date: "2026-01-30"
tags: ["javascript", "architecture"]
slug: "vanilla-js-comment-module"
---

안녕하세요. 이번 글에서는 네이버 공통 댓글 모듈 종료에 대응하여 프레임워크 독립적인 Vanilla JS 댓글 모듈을 자체 개발하고, 기존 Nuxt 3 프로젝트에 통합한 과정을 공유합니다.

## 배경: 네이버 공통 댓글 모듈 종료

저희 서비스는 크리에이터 공지사항, 이벤트 상세, 웹툰 이벤트 등 총 3개 페이지에서 네이버 공통 댓글 모듈을 사용하고 있었습니다. 네이버 댓글 모듈은 외부 스크립트를 동적 로드하는 방식으로 동작했습니다.

```javascript
const commentBoxLoader = function (htOption) {
  window.__htCboxOption = htOption;
  const s = document.createElement('script');
  s.src = `${htOption.sDomain}/js/cbox.core.js?v=${Math.floor(
    new Date().getTime() / 1200000
  )}`;
  document.head.appendChild(s);
};

commentBoxLoader({
  sDomain: 'https://ssl.pstatic.net/static.cbox',
  sApiDomain: 'https://apis.naver.com/commentBox/cbox6',
  sTicket: $env.sTicket,
  sObjectId: sObjectId,
  bManager: props.connectedCreator,
  aFormation: ['count', 'write', 'list', 'page', 'view'],
  // ...
});
```

네이버 CDN에서 스크립트를 가져오고, 네이버 API 서버와 통신하며, CSS 스킨까지 네이버 쪽 리소스에 의존하는 구조였습니다. 이 모듈의 서비스가 종료된다는 것은 댓글 기능 전체가 사라진다는 의미였기에, 자체 댓글 모듈 개발이 필요했습니다.

## 현황 분석: 무엇을 만들어야 하는가

자체 모듈을 개발하기에 앞서, 먼저 기존 네이버 댓글 모듈이 서비스에서 어떻게 사용되고 있는지 분석했습니다.

| 사용처 | 파일 경로 | 특이사항 |
|--------|-----------|----------|
| 크리에이터 공지사항 | `CreatorNoticeDetails.vue` | `bManager` 옵션으로 작성자 표시 |
| 이벤트 상세 | `events/[eventId].vue` | `allowedComment` 플래그 |
| 웹툰 이벤트 | `events/manual/webtoon.vue` | 수동 이벤트 페이지 |

세 곳 모두 댓글 목록 조회, 작성, 수정, 삭제, 페이지네이션이라는 기본 기능을 사용하고 있었고, 크리에이터 공지사항에서는 추가로 작성자 뱃지 표시(`bManager`)와 모바일/데스크톱 CSS 분기가 필요했습니다.

이 분석을 토대로 자체 모듈에 필요한 기능 목록을 정리했습니다.

- **필수**: 댓글 CRUD, 대댓글, 페이지네이션, 작성자 뱃지, 반응형 디자인
- **권장**: 좋아요, 스티커, 다국어(한국어/영어), 테마(라이트/다크)
- **보안**: XSS 방지, 인증/인가

## 왜 Vanilla JS인가

댓글 모듈을 개발할 때 가장 먼저 결정해야 할 것은 어떤 기술 스택으로 만들 것인가였습니다. Vue 컴포넌트, React 컴포넌트, 또는 프레임워크 없는 Vanilla JS 중에서 선택해야 했습니다.

### 현실적 제약

저희 서비스는 현재 Nuxt 3(Vue 3) 기반이지만, 같은 조직 내에 React 기반 프로젝트도 존재합니다. Vue 컴포넌트로 만들면 React 프로젝트에서 사용할 수 없고, 반대도 마찬가지입니다. 기존 네이버 댓글 모듈이 프레임워크에 관계없이 어디서든 동작했던 것처럼, 자체 모듈도 동일한 범용성을 가져야 했습니다.

### Vanilla JS를 선택한 이유

**1. 프레임워크 독립성**

Vanilla JS로 만들면 React, Vue, Angular, Svelte, 심지어 프레임워크 없는 정적 HTML 페이지까지 어디서든 동작합니다. DOM API는 모든 브라우저가 지원하는 표준이므로, 특정 런타임에 종속되지 않습니다.

```javascript
// Vue에서 사용
onMounted(() => {
  CommentBox.init({ container: '#comment-box', objectId: 'article-123' });
});

// React에서 사용
useEffect(() => {
  CommentBox.init({ container: containerRef.current, objectId: 'article-123' });
  return () => CommentBox.destroy(containerRef.current);
}, []);

// 정적 HTML에서 사용
<script>
  CommentBox.init({ container: '#comment-box', objectId: 'article-123' });
</script>
```

**2. 외부 의존성 최소화**

프레임워크 기반 컴포넌트는 해당 프레임워크를 런타임 의존성으로 가져가야 합니다. 반면 Vanilla JS 모듈의 프로덕션 의존성은 XSS 방지를 위한 DOMPurify 단 하나뿐입니다. 번들 크기가 작고, 소비자 프로젝트의 프레임워크 버전 업그레이드에도 영향을 받지 않습니다.

**3. 기존 네이버 모듈과 동일한 통합 방식**

네이버 댓글 모듈은 전역 객체(`window.__htCboxOption`)에 옵션을 설정하고 스크립트를 로드하는 방식이었습니다. 자체 모듈도 비슷한 패턴(`CommentBox.init(options)`)을 유지하면 기존 통합 코드의 변경을 최소화할 수 있었습니다.

### 대신 감수해야 하는 것

Vanilla JS를 선택하면서 프레임워크가 제공하는 반응형 상태 관리, 가상 DOM, 선언적 UI 등의 편의를 포기해야 했습니다. 이를 보완하기 위해 직접 상태 관리 로직을 구현하고, 이벤트 위임 패턴으로 DOM 이벤트를 효율적으로 처리하며, 템플릿 리터럴로 UI를 구성하는 전략을 택했습니다. 이 부분은 아래 아키텍처 절에서 자세히 다루겠습니다.

## 아키텍처 설계

### 프로젝트 구조

```
ogq-comment-box/
├── src/
│   ├── core/                    # 핵심 로직
│   │   ├── CommentBox.ts        # 싱글톤 매니저
│   │   ├── CommentBoxInstance.ts # 개별 인스턴스
│   │   └── EventEmitter.ts      # 이벤트 시스템
│   ├── api/                     # API 레이어
│   │   ├── CommentAPI.ts        # 인터페이스 정의
│   │   ├── MockAPI.ts           # Mock 구현 (메모리)
│   │   └── HttpAPI.ts           # HTTP 구현 (서버 연동)
│   ├── ui/
│   │   ├── templates/           # DOM 템플릿
│   │   └── styles/              # SCSS 스타일
│   ├── utils/                   # 유틸리티
│   │   ├── sanitize.ts          # XSS 방지
│   │   ├── datetime.ts          # 시간 포맷
│   │   └── dom.ts               # DOM 헬퍼
│   ├── i18n/                    # 다국어 (ko, en)
│   ├── types/                   # TypeScript 타입
│   └── index.ts                 # 엔트리포인트
├── dist/                        # 빌드 결과물
└── examples/                    # 데모
```

### 핵심 설계 패턴

#### 1. 싱글톤 매니저 패턴

한 페이지에 여러 댓글 영역이 존재할 수 있으므로, 인스턴스를 중앙에서 관리하는 매니저가 필요했습니다.

```typescript
class CommentBoxManager {
  private instances: Map<string, CommentBoxInstance> = new Map();

  init(options: CommentBoxOptions): CommentBoxInstance {
    const key = resolveContainerKey(options.container);

    // 같은 컨테이너에 재초기화 시 기존 인스턴스 정리
    if (this.instances.has(key)) {
      this.instances.get(key)!.destroy();
    }

    const instance = new CommentBoxInstance(this.normalizeOptions(options));
    this.instances.set(key, instance);
    return instance;
  }

  destroy(container: string | HTMLElement): void { /* ... */ }
  destroyAll(): void { /* ... */ }
  getInstance(container: string | HTMLElement): CommentBoxInstance | undefined { /* ... */ }
}

// 싱글톤 export
const CommentBox = new CommentBoxManager();
export default CommentBox;
```

`CommentBox.init()`으로 생성하고, `CommentBox.destroy()`로 정리하는 단순한 인터페이스를 외부에 노출합니다. 내부적으로는 `Map`으로 인스턴스를 추적하며, 같은 컨테이너에 중복 초기화되면 기존 인스턴스를 자동 정리합니다.

#### 2. 이벤트 위임

프레임워크 없이 동적 DOM을 다룰 때 가장 중요한 패턴입니다. 댓글 목록은 페이지네이션, 답글 펼침 등으로 동적으로 변하는데, 개별 요소에 리스너를 붙이면 메모리 누수와 관리 복잡성이 생깁니다.

```typescript
function delegate<T extends HTMLElement>(
  container: HTMLElement,
  selector: string,
  eventType: string,
  handler: (event: Event, target: T) => void
): () => void {
  const listener = (event: Event) => {
    const target = (event.target as Element).closest(selector) as T | null;
    if (target && container.contains(target)) {
      handler(event, target);
    }
  };
  container.addEventListener(eventType, listener);
  return () => container.removeEventListener(eventType, listener); // cleanup 함수 반환
}
```

컨테이너 하나에 이벤트 리스너를 등록하고, 이벤트 버블링을 활용해 하위 요소의 이벤트를 감지합니다. 반환된 cleanup 함수는 인스턴스 소멸 시 호출하여 메모리 누수를 방지합니다.

실제 사용 예시는 다음과 같습니다.

```typescript
// 등록 버튼 클릭 - 동적으로 생성되는 버튼도 감지
const cleanupSubmit = delegate(
  this.container,
  '.cb-editor-submit',
  'click',
  (_, target) => this.handleEditorSubmit(target.closest('.cb-editor')!)
);
this.cleanupFunctions.push(cleanupSubmit);
```

#### 3. API 추상화 (Strategy 패턴)

백엔드 API가 아직 준비되지 않은 상태에서 프론트엔드 개발을 진행해야 했기 때문에, API 레이어를 인터페이스로 추상화했습니다.

```typescript
interface CommentAPI {
  getComments(params: GetCommentsParams): Promise<GetCommentsResponse>;
  createComment(objectId: string, data: CreateCommentData): Promise<Comment>;
  updateComment(commentId: string, data: UpdateCommentData): Promise<Comment>;
  deleteComment(commentId: string): Promise<void>;
  getReplies(parentId: string, params: GetRepliesParams): Promise<GetRepliesResponse>;
  createReply(parentId: string, data: CreateCommentData): Promise<Comment>;
  likeComment(commentId: string): Promise<Comment>;
  unlikeComment(commentId: string): Promise<Comment>;
}
```

이 인터페이스를 기반으로 두 가지 구현체를 만들었습니다.

- **MockAPI**: 메모리 배열에 데이터를 저장하는 개발/데모용 구현체. 네트워크 지연 시뮬레이션 포함.
- **HttpAPI**: `fetch()`로 실제 서버와 통신하는 프로덕션 구현체.

```typescript
// 개발 시 - Mock API (기본값)
CommentBox.init({
  container: '#comment-box',
  objectId: 'article-123',
});

// 서버 연동 시 - HTTP API
import { HttpAPI } from '@ogqcorp/comment-box';
CommentBox.init({
  container: '#comment-box',
  objectId: 'article-123',
  api: new HttpAPI('/api/comments'),
});
```

소비자 코드에서 API 구현체만 교체하면 동작이 전환됩니다. 이 덕분에 백엔드 개발과 프론트엔드 개발을 완전히 병렬로 진행할 수 있었습니다.

#### 4. 템플릿 리터럴 기반 렌더링

가상 DOM 없이 UI를 구성하기 위해 템플릿 리터럴 함수를 사용했습니다.

```typescript
export function commentItemTemplate(
  prefix: string,
  comment: Comment,
  messages: Messages,
  options: { isOwner: boolean; showManagerBadge: boolean }
): string {
  return `
    <div class="${prefix}-comment-item" data-comment-id="${escapeAttr(comment.id)}">
      <div class="${prefix}-comment-body">
        <div class="${prefix}-comment-header">
          <span class="${prefix}-author">${sanitize(comment.author.nickname)}</span>
          <span class="${prefix}-time">${formatRelativeTime(comment.createdAt)}</span>
        </div>
        <div class="${prefix}-comment-content"
             data-raw-content="${escapeAttr(comment.content)}">
          ${processContent(comment.content)}
        </div>
      </div>
    </div>
  `;
}
```

사용자 입력 값에는 반드시 `sanitize()`(DOMPurify)와 `escapeAttr()`을 적용하여 XSS를 방지했습니다. 템플릿 리터럴은 JSX나 가상 DOM 대비 빌드 과정이 단순하고, 순수 문자열이므로 `innerHTML`로 바로 삽입할 수 있다는 장점이 있습니다.

좋아요 버튼처럼 빈번한 업데이트가 필요한 부분은 전체 목록을 다시 렌더링하지 않고 해당 요소만 부분 업데이트하는 방식을 적용했습니다.

```typescript
private async toggleLike(commentId: string, buttonEl: HTMLElement): Promise<void> {
  const updated = isLiked
    ? await this.api.unlikeComment(commentId)
    : await this.api.likeComment(commentId);

  // 전체 리렌더링 대신 해당 버튼 요소만 업데이트
  const iconEl = buttonEl.querySelector(`.${prefix}-like-icon`);
  if (iconEl) {
    iconEl.innerHTML = updated.isLiked ? '&#9829;' : '&#9825;';
  }
  const countEl = buttonEl.querySelector(`.${prefix}-like-count`);
  if (countEl) {
    countEl.textContent = updated.likeCount > 0 ? String(updated.likeCount) : '';
  }
}
```

#### 5. CSS 변수 기반 테마

소비자 프로젝트마다 디자인 시스템이 다르므로, CSS 변수를 통해 스타일을 재정의할 수 있도록 설계했습니다.

```scss
:root {
  --cb-color-primary: #2563eb;
  --cb-color-bg: #ffffff;
  --cb-color-text: #111827;
  --cb-color-border: #e5e7eb;
  --cb-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --cb-radius-sm: 4px;
  --cb-radius-md: 8px;
}

// 다크 테마
.cb-container--dark {
  --cb-color-bg: #1f2937;
  --cb-color-text: #f9fafb;
  --cb-color-border: #4b5563;
}
```

소비자 프로젝트에서는 CSS 변수만 덮어쓰면 됩니다. 실제로 Nuxt 프로젝트에 통합할 때 아래와 같이 디자인 시스템에 맞게 오버라이딩했습니다.

```scss
// nom-market-front/src/assets/scss/_comment-box.scss
:root {
  --cb-color-primary: #00c389;
  --cb-color-primary-hover: #14a57a;
  --cb-font-family: 'Pretendard', 'Noto Sans KR', -apple-system, sans-serif;
  --cb-radius-md: 12px;
}
```

## 빌드와 배포

Vite의 라이브러리 모드를 활용하여 ES Module, UMD, CommonJS 세 가지 포맷으로 빌드했습니다.

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    lib: {
      entry: 'src/index.ts',
      name: 'CommentBox',
      formats: ['es', 'umd', 'cjs'],
      fileName: (format) => `comment-box.${format}.js`,
    },
  },
});
```

배포는 GitHub Packages를 사용했습니다. `npm version patch && npm publish` 명령으로 버전을 올리고 배포하면, 소비자 프로젝트에서 `npm install @ogqcorp/comment-box`로 설치할 수 있습니다.

개발 단계에서는 `npm link`를 활용해 로컬 빌드 결과물을 소비자 프로젝트에 즉시 반영하며 작업했습니다.

## Nuxt 3 통합

### SSR 회피

Vanilla JS 모듈은 DOM API에 의존하므로 서버 사이드에서 실행하면 에러가 발생합니다. Nuxt 3의 `import.meta.client` 가드로 클라이언트 환경에서만 모듈을 로드했습니다.

```javascript
let CommentBox = null;
let HttpAPI = null;

if (import.meta.client) {
  const mod = await import('@ogqcorp/comment-box');
  CommentBox = mod.default || mod.CommentBox;
  HttpAPI = mod.HttpAPI;
  await import('@ogqcorp/comment-box/style.css');
}
```

### Mock 서버 API 구성

백엔드 API가 준비되기 전까지 Nuxt 서버 API 라우트로 Mock 서버를 구성했습니다. `HttpAPI` 구현체가 호출하�� 엔드포인트와 동일한 경로에 핸들러를 만들어, 프론트엔드 코드 변경 없이 나중에 실제 서버로 전환할 수 있도록 했습니다.

```
src/server/
├── utils/commentStore.ts        # 인메모리 저장소
└── api/comments/
    ├── index.get.ts             # GET  /api/comments
    ├── index.post.ts            # POST /api/comments
    ├── [id].put.ts              # PUT  /api/comments/:id
    ├── [id].delete.ts           # DELETE /api/comments/:id
    └── [id]/
        ├── replies.get.ts       # GET  /api/comments/:id/replies
        ├── replies.post.ts      # POST /api/comments/:id/replies
        ├── like.post.ts         # POST /api/comments/:id/like
        └── unlike.post.ts       # POST /api/comments/:id/unlike
```

처음에는 JSON 파일에 데이터를 저장했지만, Nuxt 개발 서버의 HMR(Hot Module Replacement)이 JSON 파일 변경을 감지하여 불필요한 리로드가 발생하는 문제가 있었습니다. 이를 해결하기 위해 서버 프로세스 메모리에 데이터를 저장하는 인메모리 방식으로 전환했습니다.

### 인증 및 스티커 연동

댓글 모듈의 `auth` 옵션을 통해 기존 서비스의 인증 시스템(Pinia 스토어)과 연동했습니다.

```typescript
CommentBox.init({
  container: '#comment-box',
  objectId: notice.value.commentObjectId,
  api: new HttpAPI('/api/comments'),
  locale: 'ko',
  isManager: props.connectedCreator,
  auth: {
    isLoggedIn: () => isAuthorizedUser.value,
    getUserInfo: () => ({
      id: getAuthUser.value.customerId,
      nickname: getAuthUser.value.nickname,
      profileUrl: getAuthUser.value.profileUrl,
    }),
    onLoginRequired: () => {
      permissionCheck(); // 기존 로그인 유도 로직 재사용
    },
  },
  sticker: {
    enabled: true,
    groups: stickerGroups,
    onStickerPurchase: () => {
      navigateTo('/artworks/sticker');
    },
  },
});
```

콜백 기반 인터페이스 덕분에 모듈 내부에서는 인증 구현체를 전혀 알 필요가 없고, 소비자 프로젝트가 자체 인증 방식을 주입하는 구조입니다.

## 마치며

이번 작업을 통해 외부 서비스 종료라는 상황에서 자체 모듈을 설계하고 개발하는 경험을 할 수 있었습니다. 특히 "어떤 프레임워크에서든 동작해야 한다"는 요구사항이 Vanilla JS 선택, API 추상화, 콜백 기반 인터페이스 등 여러 설계 결정의 출발점이 되었습니다.

프레임워크 없이 개발하면서 상태 관리, 이벤트 핸들링, DOM 업데이트 등 프레임워크가 추상화해주는 영역들을 직접 다루게 되었는데, 이 과정이 프레임워크의 동작 원리를 더 깊이 이해하는 계기가 되기도 했습니다.

현재는 Mock 서버로 동작하고 있으며, 실제 백엔드 API 연동 후 기존 네이버 댓글 모듈을 완전히 대체할 예정입니다. API 인터페이스가 동일하게 설계되어 있으므로, `HttpAPI`의 base URL만 변경하면 전환이 완료됩니다.

## 참고 자료

- [DOMPurify - XSS Sanitizer](https://github.com/cure53/DOMPurify)
- [Vite Library Mode](https://vite.dev/guide/build#library-mode)
- [Event Delegation Pattern - JavaScript.info](https://javascript.info/event-delegation)
- [GitHub Packages](https://docs.github.com/en/packages)
